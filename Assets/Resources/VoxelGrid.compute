// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS_Clear
#pragma kernel CS_Static
#pragma kernel CS_SmokeOrigin
#pragma kernel CS_FillSmoke
#pragma kernel CS_VoxelizeScene

RWTexture2D<float4> Result;
RWStructuredBuffer<int> _Voxels;
RWStructuredBuffer<int> _SmokeVoxels;
RWStructuredBuffer<int> _StaticVoxels;

RWStructuredBuffer<float3> _MeshVertices;
RWStructuredBuffer<int> _MeshTriangleIndices;
float4x4 _MeshLocalToWorld;

float3 _VoxelResolution, _BoundsExtent, _Radius, _SmokeOrigin, _positionOffset;
float _VoxelSize;
int _MaxFillStep;
uint _numberOfTriangles;
float3 _VoxelPosition;
float _IntersectionBias;

struct Triangle
{
    float3 a, b, c;
};

struct AABB
{
    float3 center;
    float3 extents;
};

float Round(float number)
{
    float fractionalPart = number - floor(number);
    if (fractionalPart >= 0.5f) {
        return ceil(number);
    }
    return floor(number);
}

float3 calculateVoxelCenterPosition(uint3 gridPosition)
{
    // map from grid resolution coordinates to shifted world coordinates
    float3 shiftedWorldPos;
    shiftedWorldPos.x = (gridPosition.x / _VoxelResolution.x) * (_BoundsExtent.x * 2);
    shiftedWorldPos.z = (gridPosition.z / _VoxelResolution.z) * (_BoundsExtent.z * 2);
    shiftedWorldPos.y = (gridPosition.y / _VoxelResolution.y) * (_BoundsExtent.y * 2);
    
    // map to world position
    float3 worldPosition;
    worldPosition.x = shiftedWorldPos.x - _BoundsExtent.x;
    worldPosition.y = shiftedWorldPos.y;
    worldPosition.z = shiftedWorldPos.z - _BoundsExtent.z;
    
    return worldPosition;
}

float3 shiftSmokeOriginPosition(float3 originPosition)
{
    originPosition = _SmokeOrigin % _BoundsExtent;
    // map from ranges [-15, 15] to [0, 30]
    originPosition.x = originPosition.x + _BoundsExtent.x;
    originPosition.z = originPosition.z + _BoundsExtent.z;
    
    // map coordinates to grid resolution - [0, 30] to [0, 60]
    originPosition.x = originPosition.x / (_BoundsExtent.x * 2) * _VoxelResolution.x;
    originPosition.y = originPosition.y / (_BoundsExtent.y * 2) * _VoxelResolution.y;
    originPosition.z = originPosition.z / (_BoundsExtent.z * 2) * _VoxelResolution.z;

    originPosition.x = Round(originPosition.x);
    originPosition.y = Round(originPosition.y);
    originPosition.z = Round(originPosition.z);
    
    return originPosition;
}


uint to1D(float3 position) {
    
    return position.x + position.y * _VoxelResolution.x + position.z * _VoxelResolution.x * _VoxelResolution.y;
}

uint3 to3D(uint index) {
    float x = index % (_VoxelResolution.x);
    float y = (index / _VoxelResolution.x) % _VoxelResolution.y;
    float z = index / (_VoxelResolution.x * _VoxelResolution.y);

    uint positionX, positionY, positionZ;
    positionX = x;
    positionY = y;
    positionZ = z;
    
    return uint3(positionX, positionY, positionZ);
}

bool IntersectsTriangleAABBSAT(float3 v0, float3 v1, float3 v2, float3 aabbExtents, float3 axis)
{
    // project triangle vertices onto the axis
    float p0 = dot(v0, axis);
    float p1 = dot(v1, axis);
    float p2 = dot(v2, axis);

    float r = aabbExtents.x * abs(dot(float3(1, 0, 0), axis)) +
              aabbExtents.y * abs(dot(float3(0, 1, 0), axis)) +
              aabbExtents.z * abs(dot(float3(0, 0, 1), axis));

    float maxP = max(p0, max(p1, p2));
    float minP = min(p0, min(p1, p2));

    return !(max(-maxP, minP) > r);
}

bool intersectionFound(Triangle tri, AABB aabb)
{
    // triangle / voxel intersection with separating axes theorem

    tri.a = tri.a - aabb.center;
    tri.b = tri.b - aabb.center;
    tri.c = tri.c - aabb.center;

    // triangle edge normals
    float3 ab = normalize(tri.b - tri.a);
    float3 bc = normalize(tri.c - tri.b);
    float3 ca = normalize(tri.c - tri.a);

    //Cross ab, bc, and ca with (1, 0, 0)
    float3 a00 = float3(0.0, -ab.z, ab.y);
    float3 a01 = float3(0.0, -bc.z, bc.y);
    float3 a02 = float3(0.0, -ca.z, ca.y);

    //Cross ab, bc, and ca with (0, 1, 0)
    float3 a10 = float3(ab.z, 0.0, -ab.x);
    float3 a11 = float3(bc.z, 0.0, -bc.x);
    float3 a12 = float3(ca.z, 0.0, -ca.x);

    //Cross ab, bc, and ca with (0, 0, 1)
    float3 a20 = float3(-ab.y, ab.x, 0.0);
    float3 a21 = float3(-bc.y, bc.x, 0.0);
    float3 a22 = float3(-ca.y, ca.x, 0.0);

    if (
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a00) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a01) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a02) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a10) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a11) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a12) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a20) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a21) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a22) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, float3(1, 0, 0)) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, float3(0, 1, 0)) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, float3(0, 0, 1)) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, cross(ab, bc))
   )
        return false;

    return true;
}

[numthreads(128,1,1)]
void CS_Clear (uint id : SV_DispatchThreadID)
{
    // empty voxel
    _Voxels[id.x] = 0;
}

[numthreads(128,1,1)]
void CS_Static (uint id : SV_DispatchThreadID)
{
    // static voxel
    _Voxels[id.x] = 1;
}

[numthreads(1,1,1)]
void CS_SmokeOrigin (uint3 id : SV_DispatchThreadID)
{
    float3 originPosition = _SmokeOrigin;
    originPosition = shiftSmokeOriginPosition(originPosition);
    uint voxelIndex = to1D(originPosition);
    _SmokeVoxels[voxelIndex] = 5;
    
}

[numthreads(1,1,1)]
void CS_FillSmoke (int3 id : SV_DispatchThreadID)
{
    [branch]
    if (id.x >= 0 && id.x < _VoxelResolution.x &&
       id.y >= 0 && id.y < _VoxelResolution.y &&
       id.z >= 0 && id.z < _VoxelResolution.z)
    {
        uint voxelIndex = id.x + id.y * _VoxelResolution.x + id.z * _VoxelResolution.x * _VoxelResolution.y;
        if (_SmokeVoxels[voxelIndex] == 5)
        {
            // smoke origin
            _SmokeVoxels[voxelIndex] = 10;
            // skip further computation for the voxel
            return;
        }
        
        // covert voxel index to 3D position in the voxel grid
        uint voxelX = id.x;
        uint voxelY = id.y;
        uint voxelZ = id.z;
        uint3 voxelGridPosition;
        voxelGridPosition.x = voxelX;
        voxelGridPosition.y = voxelY;
        voxelGridPosition.z = voxelZ;
        
        // calculate the world position of the voxel
        float3 worldPositionVoxel = calculateVoxelCenterPosition(voxelGridPosition);
        float3 inR = worldPositionVoxel - _SmokeOrigin;
        inR = inR / _Radius;
        float distance = sqrt(inR.x * inR.x + inR.y * inR.y + inR.z * inR.z);
        
        if (distance < 1)
        {
            _SmokeVoxels[voxelIndex] = 1;
        }
        
        
    }
    
}


[numthreads(1,1,1)]
void CS_VoxelizeScene (int3 id : SV_DispatchThreadID)
{
    [branch]
    if (id.x >= 0 && id.x < _VoxelResolution.x &&
       id.y >= 0 && id.y < _VoxelResolution.y &&
       id.z >= 0 && id.z < _VoxelResolution.z)
    {
        uint voxelIndex = id.x + id.y * _VoxelResolution.x + id.z * _VoxelResolution.x * _VoxelResolution.y;

        // covert voxel index to 3D position in the voxel grid
        uint voxelX = id.x;
        uint voxelY = id.y;
        uint voxelZ = id.z;
        uint3 voxelGridPosition;
        voxelGridPosition.x = voxelX;
        voxelGridPosition.y = voxelY;
        voxelGridPosition.z = voxelZ;

        // calculate the world position of the voxel
        float3 worldPositionVoxel = calculateVoxelCenterPosition(voxelGridPosition);

        AABB aabb;
        aabb.center = worldPositionVoxel + _VoxelSize/2;
        aabb.extents = _VoxelSize * _IntersectionBias;
        
        // compare voxel to every single triangle to see if they overlap

        for (uint i = 0; i < _numberOfTriangles; i = i + 3)
        {
            Triangle tri;
            
            // retrieve the vertices (a, b, c) positions of triangle in world space 
            tri.a = mul(_MeshLocalToWorld, float4(_MeshVertices[_MeshTriangleIndices[i]], 1.0f)).xyz;
            tri.b = mul(_MeshLocalToWorld, float4(_MeshVertices[_MeshTriangleIndices[i+1]], 1.0f)).xyz;
            tri.c = mul(_MeshLocalToWorld, float4(_MeshVertices[_MeshTriangleIndices[i+2]], 1.0f)).xyz;

            
            // check if current triangle intersects with the voxel
            [branch]
            if (intersectionFound(tri, aabb))
            {
                _StaticVoxels[voxelIndex] = 1;
            }

            
        }
    }
}

