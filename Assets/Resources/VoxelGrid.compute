// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS_Clear
#pragma kernel CS_Static
#pragma kernel CS_SmokeOrigin
#pragma kernel CS_FillSmoke
#pragma kernel CS_VoxelizeScene

RWTexture2D<float4> Result;
RWStructuredBuffer<int> _Voxels;
RWStructuredBuffer<int> _SmokeVoxels;
RWStructuredBuffer<int> _StaticVoxels;

float3 _VoxelResolution, _BoundsExtent, _Radius, _SmokeOrigin, _positionOffset;
float _VoxelSize;
int _MaxFillStep;
float3 _VoxelPosition;


float3 calculateVoxelCenterPosition(uint3 gridPosition)
{
    // map from grid resolution coordinates to shifted world coordinates
    float3 shiftedWorldPos;
    shiftedWorldPos.x = (gridPosition.x / _VoxelResolution.x) * (_BoundsExtent.x * 2);
    shiftedWorldPos.z = (gridPosition.z / _VoxelResolution.z) * (_BoundsExtent.z * 2);
    shiftedWorldPos.y = (gridPosition.y / _VoxelResolution.y) * (_BoundsExtent.y * 2);
    
    // map to world position
    float3 worldPosition;
    worldPosition.x = shiftedWorldPos.x - _BoundsExtent.x;
    worldPosition.y = shiftedWorldPos.y;
    worldPosition.z = shiftedWorldPos.z - _BoundsExtent.z;
    
    return worldPosition;
}

float3 shiftSmokeOriginPosition(float3 originPosition)
{
    //originPosition = _SmokeOrigin % _BoundsExtent;
    // map from ranges [-15, 15] to [0, 30]
    originPosition.x = originPosition.x + _BoundsExtent.x;
    originPosition.z = originPosition.z + _BoundsExtent.z;
    
    // map coordinates to grid resolution - [0, 30] to [0, 60]
    originPosition.x = originPosition.x / (_BoundsExtent.x * 2) * _VoxelResolution.x;
    originPosition.z = originPosition.z / (_BoundsExtent.z * 2) * _VoxelResolution.z;
    
    return originPosition;
}

float Round(float number)
{
    float fractionalPart = number - floor(number);
    if (fractionalPart >= 0.5f) {
        return ceil(number); // Round up
    }
    return floor(number); // Round down
}

uint to1D(float3 position) {

    float positionX, positionY, positionZ;
    positionX = Round(position.x);
    positionY = Round(position.y);
    positionZ = Round(position.z);
    
    return positionX + positionY * _VoxelResolution.x + positionZ * _VoxelResolution.x * _VoxelResolution.y;
}

uint3 to3D(uint index) {
    float x = index % (_VoxelResolution.x);
    float y = (index / _VoxelResolution.x) % _VoxelResolution.y;
    float z = index / (_VoxelResolution.x * _VoxelResolution.y);

    uint positionX, positionY, positionZ;
    positionX = Round(x);
    positionY = Round(y);
    positionZ = Round(z);
    
    return uint3(positionX, positionY, positionZ);
}


[numthreads(128,1,1)]
void CS_Clear (uint id : SV_DispatchThreadID)
{
    // empty voxel
    _Voxels[id.x] = 0;
}

[numthreads(128,1,1)]
void CS_Static (uint id : SV_DispatchThreadID)
{
    // static voxel
    _Voxels[id.x] = 1;
}

[numthreads(1,1,1)]
void CS_SmokeOrigin (uint id : SV_DispatchThreadID)
{
    float3 originPosition = _SmokeOrigin;
    originPosition = shiftSmokeOriginPosition(originPosition);
    uint voxelIndex = to1D(originPosition);
    _SmokeVoxels[voxelIndex] = 15;
    
}

[numthreads(1,1,1)]
void CS_FillSmoke (int3 id : SV_DispatchThreadID)
{
    [branch]
    if (id.x >= 0 && id.x < _VoxelResolution.x &&
       id.y >= 0 && id.y < _VoxelResolution.y &&
       id.z >= 0 && id.z < _VoxelResolution.z)
    {
        uint voxelIndex = id.x + id.y * _VoxelResolution.x + id.z * _VoxelResolution.x * _VoxelResolution.y;
        if (_SmokeVoxels[voxelIndex] > 1)
        {
            _SmokeVoxels[voxelIndex] = 10;
            // skip further computation for the voxel
            return;
        }

        
        // covert voxel index to 3D position in the voxel grid
        uint3 voxelGridPosition = to3D(voxelIndex);
        
        // calculate the world position of the voxel
        float3 worldPositionVoxel = calculateVoxelCenterPosition(voxelGridPosition);
        float3 inR = worldPositionVoxel - _SmokeOrigin;
        inR = inR/_Radius;
        float distance = sqrt(inR.x*inR.x + inR.y*inR.y + inR.z*inR.z);

        if (distance <= 1)
        {
            _SmokeVoxels[voxelIndex] = 1;
        }
        
    }
    
}


[numthreads(8,8,1)]
void CS_VoxelizeScene (uint3 id : SV_DispatchThreadID)
{
    
}

