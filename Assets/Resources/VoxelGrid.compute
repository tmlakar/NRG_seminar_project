// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS_Clear
#pragma kernel CS_Static
#pragma kernel CS_SmokeOrigin
#pragma kernel CS_FillSmoke
#pragma kernel CS_VoxelizeScene

RWTexture2D<float4> Result;
RWStructuredBuffer<int> _Voxels;
RWStructuredBuffer<int> _SmokeVoxels;
RWStructuredBuffer<int> _StaticVoxels;

float3 _VoxelResolution, _BoundsExtent, _Radius, _SmokeOrigin, _positionOffset;
float _VoxelSize;
int _MaxFillStep;

float3 shiftSmokeOriginPosition(float3 originPosition)
{
    //originPosition = _SmokeOrigin % _BoundsExtent;
    // map from ranges [-15, 15] to [0, 30]
    originPosition.x = originPosition.x + _BoundsExtent.x;
    originPosition.z = originPosition.z + _BoundsExtent.z;
    
    // map coordinates to grid resolution - [0, 30] to [0, 60]
    originPosition.x = originPosition.x / (_BoundsExtent.x * 2) * _VoxelResolution.x;
    originPosition.z = originPosition.z / (_BoundsExtent.z * 2) * _VoxelResolution.z;
    
    return originPosition;
}

float Round(float number)
{
    float fractionalPart = number - floor(number);
    if (fractionalPart >= 0.5f) {
        return ceil(number); // Round up
    }
    return floor(number); // Round down
}

uint to1D(float3 position) {

    float positionX, positionY, positionZ;
    positionX = Round(position.x);
    positionY = Round(position.y);
    positionZ = Round(position.z);
    
    return positionX + positionY * _VoxelResolution.x + positionZ * _VoxelResolution.x * _VoxelResolution.y;
}

uint3 to3D(uint index) {
    uint x = index % (_VoxelResolution.x);
    uint y = (index / _VoxelResolution.x) % _VoxelResolution.y;
    uint z = index / (_VoxelResolution.x * _VoxelResolution.y);

    return uint3(x, y, z);
}

[numthreads(128,1,1)]
void CS_Clear (uint id : SV_DispatchThreadID)
{
    // empty voxel
    _Voxels[id.x] = 0;
}

[numthreads(128,1,1)]
void CS_Static (uint id : SV_DispatchThreadID)
{
    // static voxel
    _Voxels[id.x] = 1;
}

[numthreads(1,1,1)]
void CS_SmokeOrigin (uint id : SV_DispatchThreadID)
{
    float3 originPosition = _SmokeOrigin;
    originPosition = shiftSmokeOriginPosition(originPosition);
    uint voxelIndex = to1D(originPosition);
    _SmokeVoxels[voxelIndex] = 1;
    
}

[numthreads(128,1,1)]
void CS_FillSmoke (uint id : SV_DispatchThreadID)
{
    // check if a voxel is within the smoke radius
    [branch]
    if (0 <= id.x && id.x < _VoxelResolution) {
        // calculate the world position of the voxel
        // check if the position is inside the radius

    }
    
}


[numthreads(8,8,1)]
void CS_VoxelizeScene (uint3 id : SV_DispatchThreadID)
{
    
}
