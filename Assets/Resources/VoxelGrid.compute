// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS_Clear
#pragma kernel CS_Static
#pragma kernel CS_SmokeOrigin
#pragma kernel CS_FillSmoke
#pragma kernel CS_VoxelizeScene
#pragma kernel CS_FloodFillToVoxels
#pragma kernel CS_Disperse


RWTexture2D<float4> Result;
RWStructuredBuffer<int> _Voxels;
RWStructuredBuffer<int> _SmokeVoxels;
RWStructuredBuffer<int> _StaticVoxels;
RWStructuredBuffer<int> _FloodFillVoxels;


RWStructuredBuffer<float3> _MeshVertices;
RWStructuredBuffer<int> _MeshTriangleIndices;
float4x4 _MeshLocalToWorld;

float3 _VoxelResolution, _BoundsExtent, _Radius, _SmokeOrigin, _positionOffset;
float _VoxelSize;
int _MaxFillStep;
uint _numberOfTriangles;
float3 _VoxelPosition;
float _IntersectionBias;

struct Triangle
{
    float3 a, b, c;
};

struct AABB
{
    float3 center;
    float3 extents;
};

float Round(float number)
{
    float fractionalPart = number - floor(number);
    if (fractionalPart >= 0.5f) {
        return ceil(number);
    }
    return floor(number);
}

float3 calculateVoxelCenterPosition(uint3 gridPosition)
{
    // map from grid resolution coordinates to shifted world coordinates
    float3 shiftedWorldPos;
    shiftedWorldPos.x = (gridPosition.x / _VoxelResolution.x) * (_BoundsExtent.x * 2);
    shiftedWorldPos.z = (gridPosition.z / _VoxelResolution.z) * (_BoundsExtent.z * 2);
    shiftedWorldPos.y = (gridPosition.y / _VoxelResolution.y) * (_BoundsExtent.y * 2);
    
    // map to world position
    float3 worldPosition;
    worldPosition.x = shiftedWorldPos.x - _BoundsExtent.x;
    worldPosition.y = shiftedWorldPos.y;
    worldPosition.z = shiftedWorldPos.z - _BoundsExtent.z;
    
    return worldPosition;
}

float3 shiftSmokeOriginPosition(float3 originPosition)
{
    originPosition = _SmokeOrigin % _BoundsExtent;
    // map from ranges [-15, 15] to [0, 30]
    originPosition.x = originPosition.x + _BoundsExtent.x;
    originPosition.z = originPosition.z + _BoundsExtent.z;
    
    // map coordinates to grid resolution - [0, 30] to [0, 60]
    originPosition.x = originPosition.x / (_BoundsExtent.x * 2) * _VoxelResolution.x;
    originPosition.y = originPosition.y / (_BoundsExtent.y * 2) * _VoxelResolution.y;
    originPosition.z = originPosition.z / (_BoundsExtent.z * 2) * _VoxelResolution.z;

    originPosition.x = Round(originPosition.x);
    originPosition.y = Round(originPosition.y);
    originPosition.z = Round(originPosition.z);
    
    return originPosition;
}


uint to1D(float3 position) {
    
    return position.x + position.y * _VoxelResolution.x + position.z * _VoxelResolution.x * _VoxelResolution.y;
}

uint3 to3D(uint index) {
    float x = index % (_VoxelResolution.x);
    float y = (index / _VoxelResolution.x) % _VoxelResolution.y;
    float z = index / (_VoxelResolution.x * _VoxelResolution.y);

    uint positionX, positionY, positionZ;
    positionX = x;
    positionY = y;
    positionZ = z;
    
    return uint3(positionX, positionY, positionZ);
}

bool IntersectsTriangleAABBSAT(float3 v0, float3 v1, float3 v2, float3 aabbExtents, float3 axis)
{
    float p0 = dot(v0, axis);
    float p1 = dot(v1, axis);
    float p2 = dot(v2, axis);

    float r = aabbExtents.x * abs(dot(float3(1, 0, 0), axis)) +
              aabbExtents.y * abs(dot(float3(0, 1, 0), axis)) +
              aabbExtents.z * abs(dot(float3(0, 0, 1), axis));

    float maxP = max(p0, max(p1, p2));
    float minP = min(p0, min(p1, p2));

    return !(max(-maxP, minP) > r);
}

bool intersectionFound(Triangle tri, AABB aabb)
{
    // triangle / voxel intersection with separating axes theorem - code based on and copied from https://bronsonzgeb.com/index.php/2021/05/29/gpu-mesh-voxelizer-part-2/

    tri.a = tri.a - aabb.center;
    tri.b = tri.b - aabb.center;
    tri.c = tri.c - aabb.center;

   
    float3 ab = normalize(tri.b - tri.a);
    float3 bc = normalize(tri.c - tri.b);
    float3 ca = normalize(tri.c - tri.a);

    
    float3 a00 = float3(0.0, -ab.z, ab.y);
    float3 a01 = float3(0.0, -bc.z, bc.y);
    float3 a02 = float3(0.0, -ca.z, ca.y);

    
    float3 a10 = float3(ab.z, 0.0, -ab.x);
    float3 a11 = float3(bc.z, 0.0, -bc.x);
    float3 a12 = float3(ca.z, 0.0, -ca.x);

    
    float3 a20 = float3(-ab.y, ab.x, 0.0);
    float3 a21 = float3(-bc.y, bc.x, 0.0);
    float3 a22 = float3(-ca.y, ca.x, 0.0);

    if (
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a00) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a01) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a02) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a10) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a11) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a12) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a20) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a21) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, a22) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, float3(1, 0, 0)) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, float3(0, 1, 0)) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, float3(0, 0, 1)) ||
       !IntersectsTriangleAABBSAT(tri.a, tri.b, tri.c, aabb.extents, cross(ab, bc))
   )
        return false;

    return true;
}

[numthreads(128,1,1)]
void CS_Clear (uint id : SV_DispatchThreadID)
{
    // empty voxel
    _Voxels[id.x] = 0;
}

[numthreads(128,1,1)]
void CS_Static (uint id : SV_DispatchThreadID)
{
    // static voxel
    _Voxels[id.x] = 1;
}

[numthreads(128,1,1)]
void CS_SmokeOrigin (uint3 id : SV_DispatchThreadID)
{
    float3 originPosition = _SmokeOrigin;
    originPosition = shiftSmokeOriginPosition(originPosition);
    uint voxelIndex = to1D(originPosition);
    _SmokeVoxels[voxelIndex] = _MaxFillStep;
}

void GetNeighboringVoxels(int3 voxel, int3 voxelResolution, out int3 neighbors[6]) {
    int voxelX = voxel.x;
    int voxelY = voxel.y;
    int voxelZ = voxel.z;
    
    neighbors[0] = int3(voxelX + 1, voxelY, voxelZ);
    neighbors[1] = int3(voxelX - 1, voxelY, voxelZ); 
    neighbors[2] = int3(voxelX, voxelY + 1, voxelZ); 
    neighbors[3] = int3(voxelX, voxelY - 1, voxelZ); 
    neighbors[4] = int3(voxelX, voxelY, voxelZ + 1); 
    neighbors[5] = int3(voxelX, voxelY, voxelZ - 1);
    
}

[numthreads(8,8,8)]
void CS_FillSmoke (int3 id : SV_DispatchThreadID)
{
    [branch]
    if (id.x >= 0 && id.x < _VoxelResolution.x &&
       id.y >= 0 && id.y < _VoxelResolution.y &&
       id.z >= 0 && id.z < _VoxelResolution.z)
    {
        int3 voxel = int3(id.x, id.y, id.z);
        // define neighbours in the grid for flood fill
        int3 neighbors[6];
        GetNeighboringVoxels(voxel, _VoxelResolution, neighbors);

        // convert voxel index to 3D position in the voxel grid
        uint3 voxelGridPosition;
        voxelGridPosition.x = id.x;
        voxelGridPosition.y = id.y;
        voxelGridPosition.z = id.z;
        
        uint voxelIndex = voxelGridPosition.x + voxelGridPosition.y * _VoxelResolution.x + voxelGridPosition.z * _VoxelResolution.x * _VoxelResolution.y;
        int smokeVoxelValue = _SmokeVoxels[voxelIndex];
        int staticVoxelValue = _StaticVoxels[voxelIndex];

        bool isStatic = false;
        if (staticVoxelValue > 0)
        {
            isStatic = true;
        }

        if (smokeVoxelValue > 0)
        {
            _FloodFillVoxels[voxelIndex] = smokeVoxelValue;
            return;
        }

        // calculate the world position of the voxel
        float3 worldPositionVoxel = calculateVoxelCenterPosition(voxelGridPosition);
        float3 inR = worldPositionVoxel - _SmokeOrigin;
        inR = inR / _Radius;
        float distance = sqrt(inR.x * inR.x + inR.y * inR.y + inR.z * inR.z);

        
        // radius check
        if (distance >= 1.0f)
        {
            _FloodFillVoxels[voxelIndex] = 0;
            return;
            
        }
        
        // if its inside radius, flood fill the voxels -

        // check maximum smoke fill value of neighboring voxels
        int maximumSmokeFillValue = 0;
        for (int i = 0; i < 6; i++)
        {
            int3 neighbor = neighbors[i];
            if (any(neighbor < 0) || any(_VoxelResolution < neighbor)) continue;
            // check if neighbor is valid
            int neighborVoxelIndex = neighbor.x + neighbor.y * _VoxelResolution.x + neighbor.z * _VoxelResolution.x * _VoxelResolution.y;
            int valueOfNeighbor = _SmokeVoxels[neighborVoxelIndex];
             
            if (valueOfNeighbor > maximumSmokeFillValue)
            {
                maximumSmokeFillValue = valueOfNeighbor;
            }
        }
        
      
        if (isStatic && maximumSmokeFillValue > 1)
        {
            maximumSmokeFillValue = 2;
        }

        _FloodFillVoxels[voxelIndex] = max(0, maximumSmokeFillValue-1);
        
    }
    
    
}


[numthreads(8, 8, 8)]
void CS_VoxelizeScene (int3 id : SV_DispatchThreadID)
{
    [branch]
    if (id.x >= 0 && id.x < _VoxelResolution.x &&
       id.y >= 0 && id.y < _VoxelResolution.y &&
       id.z >= 0 && id.z < _VoxelResolution.z)
    {
        uint voxelIndex = id.x + id.y * _VoxelResolution.x + id.z * _VoxelResolution.x * _VoxelResolution.y;

        // covert voxel index to 3D position in the voxel grid
        uint voxelX = id.x;
        uint voxelY = id.y;
        uint voxelZ = id.z;
        uint3 voxelGridPosition;
        voxelGridPosition.x = voxelX;
        voxelGridPosition.y = voxelY;
        voxelGridPosition.z = voxelZ;

        // calculate the world position of the voxel
        float3 worldPositionVoxel = calculateVoxelCenterPosition(voxelGridPosition);

        AABB aabb;
        aabb.center = worldPositionVoxel + _VoxelSize/2;
        aabb.extents = _VoxelSize * _IntersectionBias;
        
        // compare voxel to every single triangle to see if they overlap

        for (uint i = 0; i < _numberOfTriangles; i = i + 3)
        {
            Triangle tri;
            
            // retrieve the vertices (a, b, c) positions of triangle in world space 
            tri.a = mul(_MeshLocalToWorld, float4(_MeshVertices[_MeshTriangleIndices[i]], 1.0f)).xyz;
            tri.b = mul(_MeshLocalToWorld, float4(_MeshVertices[_MeshTriangleIndices[i+1]], 1.0f)).xyz;
            tri.c = mul(_MeshLocalToWorld, float4(_MeshVertices[_MeshTriangleIndices[i+2]], 1.0f)).xyz;

            
            // check if current triangle intersects with the voxel
            [branch]
            if (intersectionFound(tri, aabb))
            {
                _StaticVoxels[voxelIndex] = 1;
            }

            
        }
    }
}

[numthreads(8, 8, 8)]
void CS_FloodFillToVoxels(int3 id : SV_DISPATCHTHREADID) {
    [branch]
    if (id.x >= 0 && id.x < _VoxelResolution.x &&
       id.y >= 0 && id.y < _VoxelResolution.y &&
       id.z >= 0 && id.z < _VoxelResolution.z)
    {
        uint voxelIndex = id.x + id.y * _VoxelResolution.x + id.z * _VoxelResolution.x * _VoxelResolution.y;
        _SmokeVoxels[voxelIndex] = _FloodFillVoxels[voxelIndex];
    }
}


[numthreads(1, 1, 1)]
void CS_Disperse(int3 id : SV_DISPATCHTHREADID) {
    [branch]
    if (id.x >= 0 && id.x < _VoxelResolution.x &&
       id.y >= 0 && id.y < _VoxelResolution.y &&
       id.z >= 0 && id.z < _VoxelResolution.z)
    {
        
        uint3 voxelGridPosition;
        voxelGridPosition.x = id.x;
        voxelGridPosition.y = id.y;
        voxelGridPosition.z = id.z;
        
        uint voxelIndex = voxelGridPosition.x + voxelGridPosition.y * _VoxelResolution.x + voxelGridPosition.z * _VoxelResolution.x * _VoxelResolution.y;
        _SmokeVoxels[voxelIndex] = _SmokeVoxels[voxelIndex] - 1;
        
    }
}
