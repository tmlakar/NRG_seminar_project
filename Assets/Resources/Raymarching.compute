#pragma kernel CS_RayMarching
#pragma kernel CS_InitializeSmokeMask
#pragma kernel CS_InitializeSmokeAlbedo
#pragma kernel CS_BinaryRayMarching
#pragma kernel CS_GenerateNoise2D
#pragma kernel CS_GenerateNoise3D

#define MAX_DISTANCE 200
#define PI 3.1415926538

RWStructuredBuffer<int> _SmokeVoxels;
float3 _BoundsExtent, _VoxelResolution, _SmokeOrigin, _Radius;
int _MaxFillStep;

// textures for generating and storing noise data
// 3D
RWTexture3D<float4> _RWNoiseTex;
Texture3D<float4> _NoiseTex;
SamplerState point_repeat_sampler;
SamplerState linear_repeat_sampler;
SamplerState linear_clamp_sampler;

int _Resolution;
int _CellResolution;
int _AxisCellCount;
int _Seed;
// 2D
RWTexture2D<float4> _RWNoise2DTex;


//smoke textures
// smoke color data
RWTexture2D<float4> _SmokeTex;
// smoke depth data
RWTexture2D<float> _SmokeDepthTex;
// binary smoke mask
RWTexture2D<float> _SmokeMaskTex;
Texture2D<float> _DepthTex;

// camera transformations
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _CameraInverseViewProjection;
// camera and light properties
float3 _CameraWorldPosition;
float3 _LightColor;
float3 _LightDirection;
float3 _LightPosition;

float3 _SmokeColor, _ExtinctionColor;
float _VolumeDensity, _ShadowDensity;
float _DensityFalloff;

// width and height of texture resolution
int _TargetBufferWidth, _TargetBufferHeight;

int _totalSteps;
int _LightTotalSteps;
float _stepSize, _LightStepSize;
float _AbsorptionCoefficient, _ScatteringCoefficient;
float _AlphaThreshold;

// noise variables
float3 _NoiseResolution;
int _Octaves, _CellSize, _CellCountAxis;


// transforms a position from NDC and device depth into world space coordinates
float3 toWorldSpacePosition(float2 ndc, float depth)
{
    float4 positionClipSpace = float4(ndc * 2.0 - 1.0, depth, 1.0);
    float4 positionWorldSpace = mul(_CameraInverseViewProjection, positionClipSpace);
    float3 position = positionWorldSpace.xyz / positionWorldSpace.w; 
    return position;
}

float Round(float number)
{
    float fractionalPart = number - floor(number);
    if (fractionalPart >= 0.5f) {
        return ceil(number);
    }
    return floor(number);
}

uint to1D(float3 position) {
    return position.x + position.y * _VoxelResolution.x + position.z * _VoxelResolution.x * _VoxelResolution.y;
}

// shifts world position and then maps it to voxel grid resolution
float3 shiftPosition(float3 position)
{
    // position = position % _BoundsExtent;
    // map from ranges [-15, 15] to [0, 30]
    position.x = position.x + _BoundsExtent.x;
    position.z = position.z + _BoundsExtent.z;
    
    // map coordinates to grid resolution - [0, 30] to [0, 60]
    position.x = position.x / (_BoundsExtent.x * 2) * _VoxelResolution.x;
    position.y = position.y / (_BoundsExtent.y * 2) * _VoxelResolution.y;
    position.z = position.z / (_BoundsExtent.z * 2) * _VoxelResolution.z;

    position.x = Round(position.x);
    position.y = Round(position.y);
    position.z = Round(position.z);
    
    return position;
}

int getVoxelValue(float3 position)
{
    int value = 0;

    // // needs checking if position is inside the bounds of voxel grid
    // if not, return voxel value 0, otherwise check voxel in the grid
    bool insideBounds = false;
    float3 boundsMin = float3(-_BoundsExtent.x, 0.0f, -_BoundsExtent.z);
    float3 boundsMax = float3(_BoundsExtent.x, _BoundsExtent.y * 2, _BoundsExtent.z);

    if (position.x >= boundsMin.x && position.y >= boundsMin.y && position.z >= boundsMin.z &&
        position.x <= boundsMax.x && position.y <= boundsMax.y && position.z <= boundsMax.z)
    {
        insideBounds = true;
    }
    
    if (insideBounds) 
    {
        // shift position - borrow function from VoxelGrid compute shader
        position = shiftPosition(position);
        // to 1d
        uint voxelIndex = to1D(position);
        value = _SmokeVoxels[voxelIndex];
        return value;
    }
    return value;
    
}

// Rayleigh phase function 
float RayleighPhaseFunction(float cos_theta)
{
    return (3.0f / (16.0f*PI)) * (1 + cos_theta * cos_theta);
}

// include voxel value, distance from the volume center, density falloff function
float getDensity(float3 position)
{
    
    // current voxel value
    int voxelValue = getVoxelValue(position);
    
    float falloff = 0.0f;
    // vector from smoke origin to current position
    float3 v = position - _SmokeOrigin;
    float3 radius = _Radius;
    v = v / radius;
    
    // normalized distance from the origin
    float distance = sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    
    // density fallof
    distance = smoothstep(_DensityFalloff, 1.0f, distance);
    falloff = min(1.0f, distance);
    return saturate(saturate(voxelValue)*(1-falloff));
}

[numthreads(8,8,1)]
void CS_RayMarching (uint3 id : SV_DispatchThreadID)
{
    // convert pixel to world space
    float2 uv = (id.xy / float2(_TargetBufferWidth, _TargetBufferHeight)); // ndc
    float sceneDepth = _DepthTex.SampleLevel(linear_clamp_sampler, uv, 0).r;
    float3 sceneWorldPos = toWorldSpacePosition(uv, sceneDepth); // world position of pixel
    
    // create the ray from the camera that will be passing through current pixels's UV coordinates
    float3 rayOrigin = _CameraWorldPosition;
    float3 rayDirection = mul(_CameraInverseProjection, float4(uv*2-1, 0.0f, 1.0f)).xyz; // UV coordinates to view space
    rayDirection = mul(_CameraToWorld, float4(rayDirection, 0.0f)).xyz; // view space to world space
    rayDirection = normalize(rayDirection);

    // initialize values for ray marching
    float3 color = 0.0f; // for accumulated color along the way
    float alpha = 1.0f; // opacity

    float stepSize = 0.5f;
    float traveledDistance = 0.0f;
    float3 currentPosition = rayOrigin + traveledDistance * rayDirection; // r = o + t*d
    
    float voxelValue = getVoxelValue(currentPosition); // checks voxel value at current position of ray march
    float sceneIntersectionDistance = ((sceneWorldPos - rayOrigin) / rayDirection).x; // distance to the intersection point of ray with scene depth

    // bigger ray marching steps before we encounter smoke voxels
    while (voxelValue == 0 && traveledDistance < MAX_DISTANCE)
    {
        traveledDistance = traveledDistance + stepSize; // larger step size to cover more ground
        currentPosition = rayOrigin + traveledDistance * rayDirection;
        voxelValue = getVoxelValue(currentPosition);
    }

    // encountered smoke, continue with more precise ray marching
    if (voxelValue > 0)
    {
        traveledDistance = traveledDistance - stepSize; // one step back to avoid missing details

        // set variables before precise ray march
        float thickness = 0.0f;
        float accumulatedDensity = 0.0f;
        color = _SmokeColor;
        stepSize = _stepSize; // smaller steps for precision
        float lightStepSize = _LightStepSize; // step size when sampling ray towards the light
        int stepCount = 0;
        
        float extinctionCoefficient = _AbsorptionCoefficient + _ScatteringCoefficient;
        float3 lightDirection = normalize(_LightPosition - currentPosition);
        float cos_theta = dot(rayDirection, lightDirection);
        float phase = RayleighPhaseFunction(cos_theta);
        
        while ((stepCount < _totalSteps) && traveledDistance < sceneIntersectionDistance)
        {
            currentPosition = rayOrigin + traveledDistance * rayDirection;
            // we convert our position to voxel space, we get the voxel value at our step
            voxelValue = getVoxelValue(currentPosition);
            // add it to density sum
            float sampleDensity = getDensity(currentPosition);
            float density = sampleDensity;
            accumulatedDensity = accumulatedDensity + sampleDensity * _VolumeDensity;
            stepCount = stepCount + 1;
            traveledDistance = traveledDistance + stepSize;

            // adjustments
            // if ray march has exceeded the scene depth, stop marching
            // that way the smoke is properly obscured by existing objects
            if (traveledDistance > sceneIntersectionDistance)
            {
                return;

            }
            
            thickness = thickness + _stepSize*voxelValue;
            // update alpha - transmittance at current position
            alpha = exp(-thickness * accumulatedDensity * extinctionCoefficient);
            
            
            // ray marching towards the  light
            if (density > 0.001f)
            {
                float t = 0.0f;
                float3 positionToLight = currentPosition;
                int lightStepCount = 0;
                while (lightStepCount < _LightTotalSteps)
                {
                    t = t + density * _ShadowDensity;
                    positionToLight = positionToLight + lightStepSize*lightDirection;
                    density = getDensity(positionToLight);
                    lightStepCount = lightStepCount + 1;
                    
                }

                float3 lightTransmittance = exp(-(t/_ExtinctionColor) * extinctionCoefficient * _ShadowDensity);
                color = color + _LightColor * lightTransmittance * alpha * phase * _ScatteringCoefficient * _VolumeDensity * sampleDensity;
                
                
            }
            
            if (alpha < _AlphaThreshold)
            {
                 break;
            }
            
            
        }
        
    }
    // color
    _SmokeTex[id.xy] = float4((saturate(color)), 1.0f);
    // opacity values
    _SmokeMaskTex[id.xy] = saturate(alpha);
   
}

[numthreads(32,1,1)]
void CS_InitializeSmokeMask (uint3 id : SV_DispatchThreadID)
{
    _SmokeMaskTex[id.xy] = 0.0f;
}

[numthreads(32,1,1)]
void CS_InitializeSmokeAlbedo (uint3 id : SV_DispatchThreadID)
{
    _SmokeTex[id.xy] = 1.0f;
}


// test - just returns 1 when ray hits smoke voxels
[numthreads(8,8,1)]
void CS_BinaryRayMarching (uint3 id : SV_DispatchThreadID)
{
    
    // convert pixel to world space
    float2 uv = (id.xy / float2(_TargetBufferWidth, _TargetBufferHeight)); // ndc
    float sceneDepth = _DepthTex.SampleLevel(linear_clamp_sampler, uv, 0).r;
    float3 sceneWorldPos = toWorldSpacePosition(uv, sceneDepth); // world position of pixel
    
    // create the ray from the camera that will be passing through current pixels's UV coordinates
    float3 rayOrigin = _CameraWorldPosition;
    float3 rayDirection = mul(_CameraInverseProjection, float4(uv*2-1, 0.0f, 1.0f)).xyz; // UV coordinates to view space
    rayDirection = mul(_CameraToWorld, float4(rayDirection, 0.0f)).xyz; // view space to world space
    rayDirection = normalize(rayDirection);
    
    int encountered = 0;

    float stepSize = 0.5f;
    float traveledDistance = 0.0f;
    float3 currentPosition = rayOrigin + traveledDistance * rayDirection; // r = o + t*d
    
    float voxelValue = getVoxelValue(currentPosition); // checks voxel value at current position of ray march
    float sceneIntersectionDistance = ((sceneWorldPos - rayOrigin) / rayDirection).x; // distance to the intersection point of ray with scene depth

    // bigger ray marching steps before we encounter smoke voxels
    while (voxelValue == 0 && traveledDistance < MAX_DISTANCE)
    {
        traveledDistance = traveledDistance + stepSize; // larger step size to cover more ground
        currentPosition = rayOrigin + traveledDistance * rayDirection;
        voxelValue = getVoxelValue(currentPosition);
    }

    // encountered smoke, return value
    if (voxelValue > 0)
    {
        encountered = 1;
        _SmokeMaskTex[id.xy] = 1;
        return;
    }
   
}

// random number generator
float rand(uint seed)
{
    seed = (seed << 13) ^ seed;
    return 1.0 - ((seed * (seed * seed * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;
}

[numthreads(8,8,1)]
void CS_GenerateNoise2D (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= 0 && id.x <= _Resolution && id.y >= 0 && id.y <= _Resolution)
    {
        // cell size
        float cellSize = _Resolution / (float)_AxisCellCount;

        // current cell index
        int cellX = id.x / cellSize;
        int cellY = id.y / cellSize;

        // generate a random feature point within the cell
        uint seed = uint(cellX * 73856093 ^ cellY * 19349663) + uint(_CellResolution);
        float2 featurePoint = float2(cellX + rand(seed), cellY + rand(seed + 1)) * cellSize;

        // min distance to the feature point
        float minDist = distance(float2(id.x, id.y), featurePoint);

        // check all neighboring cells for potentially closer feature points
        for (int offsetX = -1; offsetX <= 1; offsetX++)
        {
            for (int offsetY = -1; offsetY <= 1; offsetY++)
            {
                int neighborCellX = cellX + offsetX;
                int neighborCellY = cellY + offsetY;
                if (neighborCellX >= 0 && neighborCellX < _AxisCellCount && neighborCellY >= 0 && neighborCellY < _AxisCellCount)
                {
                    uint neighborSeed = uint(neighborCellX * 73856093 ^ neighborCellY * 19349663) + uint(_CellResolution);
                    float2 neighborFeaturePoint = float2(neighborCellX + rand(neighborSeed), neighborCellY + rand(neighborSeed + 1)) * cellSize;
                    float dist = distance(float2(id.x, id.y), neighborFeaturePoint);
                    if (dist < minDist)
                    {
                        minDist = dist;
                    }
                }
            }
        }

        // normalize the distance
        float normalizedDist = minDist / (_Resolution / _AxisCellCount);

        // invert the distance and write it to output texture
        _RWNoise2DTex[id.xy] = 1 - float4(normalizedDist, normalizedDist, normalizedDist, 1.0);
    }
    
}

[numthreads(8,8,8)]
void CS_GenerateNoise3D (uint3 id : SV_DispatchThreadID)
{
    // same logic as 2d just for 3 dimensions
    if (id.x >= 0 && id.x <= _Resolution &&
        id.y >= 0 && id.y <= _Resolution &&
        id.z >= 0 && id.z <= _Resolution)
    {
        
        float cellSize = _Resolution / (float)_AxisCellCount;
        
        int cellX = id.x / cellSize;
        int cellY = id.y / cellSize;
        int cellZ = id.z / cellSize;
        
        uint seed = uint(cellX * 73856093 ^ cellY * 19349663 ^ cellZ * 83492791) + uint(_CellResolution);
        float3 featurePoint = float3(cellX + rand(seed), cellY + rand(seed + 1), cellZ + rand(seed + 2)) * cellSize;

        float minDist = distance(float3(id.x, id.y, id.z), featurePoint);

        for (int offsetX = -1; offsetX <= 1; offsetX++)
        {
            for (int offsetY = -1; offsetY <= 1; offsetY++)
            {
                for (int offsetZ = -1; offsetZ <= 1; offsetZ++)
                {
                    int neighborCellX = cellX + offsetX;
                    int neighborCellY = cellY + offsetY;
                    int neighborCellZ = cellZ + offsetZ;
                    if (neighborCellX >= 0 && neighborCellX < _AxisCellCount && neighborCellY >= 0 && neighborCellY < _AxisCellCount && neighborCellZ >= 0 && neighborCellZ < _AxisCellCount)
                    {
                        uint neighborSeed = uint(neighborCellX * 73856093 ^ neighborCellY * 19349663 ^ neighborCellZ * 83492791) + uint(_CellResolution);
                        float3 neighborFeaturePoint = float3(neighborCellX + rand(neighborSeed), neighborCellY + rand(neighborSeed + 1), neighborCellZ + rand(neighborSeed + 2)) * cellSize;
                        float dist = distance(float3(id.x, id.y, id.z), neighborFeaturePoint);
                        if (dist < minDist)
                        {
                            minDist = dist;
                        }
                    }
                }
            }
        }

        // normalize + invert
        float normalizedDist = minDist / cellSize;
        float invertedDist = 1.0 - normalizedDist;

        _RWNoiseTex[id.xyz] = float4(invertedDist, invertedDist, invertedDist, 1.0);
    }
}