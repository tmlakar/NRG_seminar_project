#pragma kernel CS_RayMarching
#pragma kernel CS_InitializeSmokeMask
#pragma kernel CS_InitializeSmokeAlbedo
#pragma kernel CS_BinaryRayMarching

#define MAX_DISTANCE 300
#define PI 3.1415926538

RWTexture2D<float4> Result;
RWStructuredBuffer<int> _SmokeVoxels;
float3 _BoundsExtent, _VoxelResolution;

// textures for generating and storing noise data
RWTexture3D<half> _RWNoiseTex;
Texture3D<half> _NoiseTex;
SamplerState point_repeat_sampler;
SamplerState linear_repeat_sampler;
SamplerState linear_clamp_sampler;

//smoke textures
// smoke color data
RWTexture2D<float4> _SmokeTex;
// smoke depth data
RWTexture2D<float> _SmokeDepthTex;
// binary smoke mask
RWTexture2D<float> _SmokeMaskTex;
Texture2D<float> _DepthTex;

// camera transformations
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _CameraInverseViewProjection;
// camera and light properties
float3 _CameraWorldPosition;
float3 _LightColor;
float3 _LightDirection;

float3 _SmokeColor, _ExtinctionColor;
float _VolumeDensity;

// width and height of texture resolution
int _TargetBufferWidth, _TargetBufferHeight;

int _totalSteps;
float _stepSize, _LightStepSize;
float _AbsorptionCoefficient, _ScatteringCoefficient;
float _AlphaThreshold;

// transforms a position from NDC and device depth into world space coordinates
float3 toWorldSpacePosition(float2 ndc, float depth)
{
    float4 positionClipSpace = float4(ndc * 2.0 - 1.0, depth, 1.0);
    float4 positionWorldSpace = mul(_CameraInverseViewProjection, positionClipSpace);
    float3 position = positionWorldSpace.xyz / positionWorldSpace.w; 
    return position;
}

float Round(float number)
{
    float fractionalPart = number - floor(number);
    if (fractionalPart >= 0.5f) {
        return ceil(number);
    }
    return floor(number);
}

uint to1D(float3 position) {
    return position.x + position.y * _VoxelResolution.x + position.z * _VoxelResolution.x * _VoxelResolution.y;
}

// shifts world position and then maps it to voxel grid resolution
float3 shiftPosition(float3 position)
{
    // position = position % _BoundsExtent;
    // map from ranges [-15, 15] to [0, 30]
    position.x = position.x + _BoundsExtent.x;
    position.z = position.z + _BoundsExtent.z;
    
    // map coordinates to grid resolution - [0, 30] to [0, 60]
    position.x = position.x / (_BoundsExtent.x * 2) * _VoxelResolution.x;
    position.y = position.y / (_BoundsExtent.y * 2) * _VoxelResolution.y;
    position.z = position.z / (_BoundsExtent.z * 2) * _VoxelResolution.z;

    position.x = Round(position.x);
    position.y = Round(position.y);
    position.z = Round(position.z);
    
    return position;
}

int getVoxelValue(float3 position)
{
    int value = 0;

    // // needs checking if position is inside the bounds of voxel grid
    // if not, return voxel value 0, otherwise check voxel in the grid
    bool insideBounds = false;
    float3 boundsMin = float3(-_BoundsExtent.x, 0.0f, -_BoundsExtent.z);
    float3 boundsMax = float3(_BoundsExtent.x, _BoundsExtent.y * 2, _BoundsExtent.z);

    if (position.x >= boundsMin.x && position.y >= boundsMin.y && position.z >= boundsMin.z &&
        position.x <= boundsMax.x && position.y <= boundsMax.y && position.z <= boundsMax.z)
    {
        insideBounds = true;
    }
    
    if (insideBounds) 
    {
        // shift position - borrow function from VoxelGrid compute shader
        position = shiftPosition(position);
        // to 1d
        uint voxelIndex = to1D(position);
        value = _SmokeVoxels[voxelIndex];
        return value;
    }
    return value;
    
}

[numthreads(8,8,1)]
void CS_RayMarching (uint3 id : SV_DispatchThreadID)
{
    // convert pixel to world space
    float2 uv = (id.xy / float2(_TargetBufferWidth, _TargetBufferHeight)); // ndc
    float sceneDepth = _DepthTex.SampleLevel(linear_clamp_sampler, uv, 0).r;
    float3 sceneWorldPos = toWorldSpacePosition(uv, sceneDepth); // world position of pixel
    
    // create the ray from the camera that will be passing through current pixels's UV coordinates
    float3 rayOrigin = _CameraWorldPosition;
    float3 rayDirection = mul(_CameraInverseProjection, float4(uv*2-1, 0.0f, 1.0f)).xyz; // UV coordinates to view space
    rayDirection = mul(_CameraToWorld, float4(rayDirection, 0.0f)).xyz; // view space to world space
    rayDirection = normalize(rayDirection);

    // initialize values for ray marching
    float3 color = 0.0f; // for accumulated color along the way
    float alpha = 1.0f; // opacity

    float stepSize = 0.5f;
    float traveledDistance = 0.0f;
    float3 currentPosition = rayOrigin + traveledDistance * rayDirection; // r = o + t*d
    
    float voxelValue = getVoxelValue(currentPosition); // checks voxel value at current position of ray march
    float sceneIntersectionDistance = ((sceneWorldPos - rayOrigin) / rayDirection).x; // distance to the intersection point of ray with scene depth

    // bigger ray marching steps before we encounter smoke voxels
    while (voxelValue == 0 && traveledDistance < MAX_DISTANCE)
    {
        
        traveledDistance = traveledDistance + stepSize; // larger step size to cover more ground
        currentPosition = rayOrigin + traveledDistance * rayDirection;
        voxelValue = getVoxelValue(currentPosition);
    }

    // encountered smoke, continue with more precise ray marching
    if (voxelValue > 0)
    {
        traveledDistance = traveledDistance - stepSize; // one step back to avoid missing details

        // set variables before precise ray march
        float thickness = 0.0f;
        float accumulatedDensity = 0.0f;
        color = _SmokeColor;
        stepSize = _stepSize; // smaller steps for precision
        float lightStepSize = _LightStepSize; // step size when sampling ray towards the light
        int stepCount = 0;
        
        float extinctionCoefficient = _AbsorptionCoefficient;
        
        while ((stepCount < _totalSteps) && traveledDistance < sceneIntersectionDistance)
        {
            currentPosition = rayOrigin + traveledDistance * rayDirection;
            // we convert our position to voxel space, we get the voxel value at our step
            voxelValue = getVoxelValue(currentPosition);
            // add it to density sum
            accumulatedDensity = accumulatedDensity + voxelValue * _VolumeDensity;

            stepCount = stepCount + 1;
            traveledDistance = traveledDistance + stepSize;
            thickness = thickness + _stepSize * voxelValue;
            // update alpha
            alpha = exp(-thickness * accumulatedDensity * extinctionCoefficient);

            if (alpha < _AlphaThreshold)
            {
                break;
            }
            
        }

        // we check if ray march has exceeded the scene depth. if our position has gone past the value of our depth texture, we want to stop marching
        // that way the smoke is properly obscured by existing objects

        // adjustments
        if (traveledDistance > sceneIntersectionDistance)
        {
            currentPosition = currentPosition - (traveledDistance - sceneIntersectionDistance) * rayDirection;
            thickness = thickness - traveledDistance - sceneIntersectionDistance;

            voxelValue = getVoxelValue(currentPosition);
            accumulatedDensity = accumulatedDensity + _VolumeDensity * voxelValue;
            alpha = exp(-thickness * accumulatedDensity * extinctionCoefficient);

        }
        
    }
    

    // color
    _SmokeTex[id.xy] = float4(saturate(color), 1.0f);
    // opacity values
    _SmokeMaskTex[id.xy] = saturate(alpha);
   
}

[numthreads(1,1,1)]
void CS_InitializeSmokeMask (uint3 id : SV_DispatchThreadID)
{
    float4 color = _SmokeMaskTex[id.xy];
    color.r = 0;
    _SmokeMaskTex[id.xy] = color.r;
}

[numthreads(1,1,1)]
void CS_InitializeSmokeAlbedo (uint3 id : SV_DispatchThreadID)
{
    _SmokeTex[id.xy] = 1.0f;
}


// just returns 1 when hit smoke voxels
[numthreads(8,8,1)]
void CS_BinaryRayMarching (uint3 id : SV_DispatchThreadID)
{
    
    // convert pixel to world space
    float2 uv = (id.xy / float2(_TargetBufferWidth, _TargetBufferHeight)); // ndc
    float sceneDepth = _DepthTex.SampleLevel(linear_clamp_sampler, uv, 0).r;
    float3 sceneWorldPos = toWorldSpacePosition(uv, sceneDepth); // world position of pixel
    
    // create the ray from the camera that will be passing through current pixels's UV coordinates
    float3 rayOrigin = _CameraWorldPosition;
    float3 rayDirection = mul(_CameraInverseProjection, float4(uv*2-1, 0.0f, 1.0f)).xyz; // UV coordinates to view space
    rayDirection = mul(_CameraToWorld, float4(rayDirection, 0.0f)).xyz; // view space to world space
    rayDirection = normalize(rayDirection);
    
    int encountered = 0;

    float stepSize = 0.5f;
    float traveledDistance = 0.0f;
    float3 currentPosition = rayOrigin + traveledDistance * rayDirection; // r = o + t*d
    
    float voxelValue = getVoxelValue(currentPosition); // checks voxel value at current position of ray march
    float sceneIntersectionDistance = ((sceneWorldPos - rayOrigin) / rayDirection).x; // distance to the intersection point of ray with scene depth

    // bigger ray marching steps before we encounter smoke voxels
    while (voxelValue == 0 && traveledDistance < MAX_DISTANCE)
    {
        traveledDistance = traveledDistance + stepSize; // larger step size to cover more ground
        currentPosition = rayOrigin + traveledDistance * rayDirection;
        voxelValue = getVoxelValue(currentPosition);
    }

    // encountered smoke, return value
    if (voxelValue > 0)
    {
        encountered = 1;
        _SmokeMaskTex[id.xy] = 1;
        return;
    }
   
}
