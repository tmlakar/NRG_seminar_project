#pragma kernel CS_RayMarching
#pragma kernel CS_InitializeSmokeMask
#pragma kernel CS_InitializeSmokeAlbedo
#pragma kernel CS_BinaryRayMarching
#pragma kernel CS_NoiseGenerate

#define MAX_DISTANCE 100
#define PI 3.1415926538

RWTexture2D<float4> Result;
RWStructuredBuffer<int> _SmokeVoxels;
float3 _BoundsExtent, _VoxelResolution, _SmokeOrigin;

// textures for generating and storing noise data
RWTexture3D<half> _RWNoiseTex;
Texture3D<half> _NoiseTex;
SamplerState point_repeat_sampler;
SamplerState linear_repeat_sampler;
SamplerState linear_clamp_sampler;

//smoke textures
// smoke color data
RWTexture2D<float4> _SmokeTex;
// smoke depth data
RWTexture2D<float> _SmokeDepthTex;
// binary smoke mask
RWTexture2D<float> _SmokeMaskTex;
Texture2D<float> _DepthTex;

// camera transformations
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _CameraInverseViewProjection;
// camera and light properties
float3 _CameraWorldPosition;
float3 _LightColor;
float3 _LightDirection;
float3 _LightPosition;

float3 _SmokeColor, _ExtinctionColor;
float _VolumeDensity, _ShadowDensity;

// width and height of texture resolution
int _TargetBufferWidth, _TargetBufferHeight;

int _totalSteps;
int _LightTotalSteps;
float _stepSize, _LightStepSize;
float _AbsorptionCoefficient, _ScatteringCoefficient;
float _AlphaThreshold;

// transforms a position from NDC and device depth into world space coordinates
float3 toWorldSpacePosition(float2 ndc, float depth)
{
    float4 positionClipSpace = float4(ndc * 2.0 - 1.0, depth, 1.0);
    float4 positionWorldSpace = mul(_CameraInverseViewProjection, positionClipSpace);
    float3 position = positionWorldSpace.xyz / positionWorldSpace.w; 
    return position;
}

float Round(float number)
{
    float fractionalPart = number - floor(number);
    if (fractionalPart >= 0.5f) {
        return ceil(number);
    }
    return floor(number);
}

uint to1D(float3 position) {
    return position.x + position.y * _VoxelResolution.x + position.z * _VoxelResolution.x * _VoxelResolution.y;
}

// shifts world position and then maps it to voxel grid resolution
float3 shiftPosition(float3 position)
{
    // position = position % _BoundsExtent;
    // map from ranges [-15, 15] to [0, 30]
    position.x = position.x + _BoundsExtent.x;
    position.z = position.z + _BoundsExtent.z;
    
    // map coordinates to grid resolution - [0, 30] to [0, 60]
    position.x = position.x / (_BoundsExtent.x * 2) * _VoxelResolution.x;
    position.y = position.y / (_BoundsExtent.y * 2) * _VoxelResolution.y;
    position.z = position.z / (_BoundsExtent.z * 2) * _VoxelResolution.z;

    position.x = Round(position.x);
    position.y = Round(position.y);
    position.z = Round(position.z);
    
    return position;
}

int getVoxelValue(float3 position)
{
    int value = 0;

    // // needs checking if position is inside the bounds of voxel grid
    // if not, return voxel value 0, otherwise check voxel in the grid
    bool insideBounds = false;
    float3 boundsMin = float3(-_BoundsExtent.x, 0.0f, -_BoundsExtent.z);
    float3 boundsMax = float3(_BoundsExtent.x, _BoundsExtent.y * 2, _BoundsExtent.z);

    if (position.x >= boundsMin.x && position.y >= boundsMin.y && position.z >= boundsMin.z &&
        position.x <= boundsMax.x && position.y <= boundsMax.y && position.z <= boundsMax.z)
    {
        insideBounds = true;
    }
    
    if (insideBounds) 
    {
        // shift position - borrow function from VoxelGrid compute shader
        position = shiftPosition(position);
        // to 1d
        uint voxelIndex = to1D(position);
        value = _SmokeVoxels[voxelIndex];
        return value;
    }
    return value;
    
}

// Rayleigh phase function 
float RayleighPhaseFunction(float cos_theta)
{
    return (3.0f / (16.0f*PI)) * (1 + cos_theta * cos_theta);
}


[numthreads(8,8,1)]
void CS_RayMarching (uint3 id : SV_DispatchThreadID)
{
    // convert pixel to world space
    float2 uv = (id.xy / float2(_TargetBufferWidth, _TargetBufferHeight)); // ndc
    float sceneDepth = _DepthTex.SampleLevel(linear_clamp_sampler, uv, 0).r;
    float3 sceneWorldPos = toWorldSpacePosition(uv, sceneDepth); // world position of pixel
    
    // create the ray from the camera that will be passing through current pixels's UV coordinates
    float3 rayOrigin = _CameraWorldPosition;
    float3 rayDirection = mul(_CameraInverseProjection, float4(uv*2-1, 0.0f, 1.0f)).xyz; // UV coordinates to view space
    rayDirection = mul(_CameraToWorld, float4(rayDirection, 0.0f)).xyz; // view space to world space
    rayDirection = normalize(rayDirection);

    // initialize values for ray marching
    float3 color = 0.0f; // for accumulated color along the way
    float alpha = 1.0f; // opacity

    float stepSize = 0.5f;
    float traveledDistance = 0.0f;
    float3 currentPosition = rayOrigin + traveledDistance * rayDirection; // r = o + t*d
    
    float voxelValue = getVoxelValue(currentPosition); // checks voxel value at current position of ray march
    float sceneIntersectionDistance = ((sceneWorldPos - rayOrigin) / rayDirection).x; // distance to the intersection point of ray with scene depth

    // bigger ray marching steps before we encounter smoke voxels
    while (voxelValue == 0 && traveledDistance < MAX_DISTANCE)
    {
        traveledDistance = traveledDistance + stepSize; // larger step size to cover more ground
        currentPosition = rayOrigin + traveledDistance * rayDirection;
        voxelValue = getVoxelValue(currentPosition);
    }

    // encountered smoke, continue with more precise ray marching
    if (voxelValue > 0)
    {
        traveledDistance = traveledDistance - stepSize; // one step back to avoid missing details

        // set variables before precise ray march
        float thickness = 0.0f;
        float accumulatedDensity = 0.0f;
        color = _SmokeColor;
        stepSize = _stepSize; // smaller steps for precision
        float lightStepSize = _LightStepSize; // step size when sampling ray towards the light
        int stepCount = 0;
        
        float extinctionCoefficient = _AbsorptionCoefficient + _ScatteringCoefficient;
        float3 lightDirection = normalize(_LightPosition - currentPosition);
        float cos_theta = dot(rayDirection, lightDirection);
        float phase = RayleighPhaseFunction(cos_theta);
        
        while ((stepCount < _totalSteps) && traveledDistance < sceneIntersectionDistance)
        {
            currentPosition = rayOrigin + traveledDistance * rayDirection;
            // we convert our position to voxel space, we get the voxel value at our step
            voxelValue = getVoxelValue(currentPosition);
            // add it to density sum
            int origVoxelVal = voxelValue;
            accumulatedDensity = accumulatedDensity + voxelValue * _VolumeDensity;
            stepCount = stepCount + 1;
            traveledDistance = traveledDistance + stepSize;

            // adjustments
            // if ray march has exceeded the scene depth, stop marching
            // that way the smoke is properly obscured by existing objects
            if (traveledDistance > sceneIntersectionDistance)
            {
                return;

            }
            
            thickness = thickness + _stepSize*voxelValue;
            // update alpha - transmittance at current position
            alpha = exp(-thickness * accumulatedDensity * extinctionCoefficient);
            
            
            // ray marching towards the  light
            if (voxelValue > 0)
            {
                float t = 0.0f;
                float3 positionToLight = currentPosition;
                int lightStepCount = 0;
                while (lightStepCount < _LightTotalSteps)
                {
                    t = t + voxelValue * _ShadowDensity;
                    positionToLight = positionToLight + lightStepSize*lightDirection;
                    voxelValue = getVoxelValue(positionToLight);
                    lightStepCount = lightStepCount + 1;
                    
                }

                float3 lightTransmittance = exp(-(t/_ExtinctionColor) * extinctionCoefficient * _ShadowDensity);
                color = color + _LightColor * lightTransmittance * alpha * phase * _ScatteringCoefficient * _VolumeDensity * origVoxelVal;
                
                
            }
            
            if (alpha < _AlphaThreshold)
            {
                 break;
            }
            
            
        }
        
    }
    // color
    _SmokeTex[id.xy] = float4((saturate(color)), 1.0f);
    // opacity values
    _SmokeMaskTex[id.xy] = saturate(alpha);
   
}

[numthreads(32,1,1)]
void CS_InitializeSmokeMask (uint3 id : SV_DispatchThreadID)
{
    _SmokeMaskTex[id.xy] = 0.0f;
}

[numthreads(32,1,1)]
void CS_InitializeSmokeAlbedo (uint3 id : SV_DispatchThreadID)
{
    _SmokeTex[id.xy] = 1.0f;
}


// just returns 1 when ray hits smoke voxels
[numthreads(8,8,1)]
void CS_BinaryRayMarching (uint3 id : SV_DispatchThreadID)
{
    
    // convert pixel to world space
    float2 uv = (id.xy / float2(_TargetBufferWidth, _TargetBufferHeight)); // ndc
    float sceneDepth = _DepthTex.SampleLevel(linear_clamp_sampler, uv, 0).r;
    float3 sceneWorldPos = toWorldSpacePosition(uv, sceneDepth); // world position of pixel
    
    // create the ray from the camera that will be passing through current pixels's UV coordinates
    float3 rayOrigin = _CameraWorldPosition;
    float3 rayDirection = mul(_CameraInverseProjection, float4(uv*2-1, 0.0f, 1.0f)).xyz; // UV coordinates to view space
    rayDirection = mul(_CameraToWorld, float4(rayDirection, 0.0f)).xyz; // view space to world space
    rayDirection = normalize(rayDirection);
    
    int encountered = 0;

    float stepSize = 0.5f;
    float traveledDistance = 0.0f;
    float3 currentPosition = rayOrigin + traveledDistance * rayDirection; // r = o + t*d
    
    float voxelValue = getVoxelValue(currentPosition); // checks voxel value at current position of ray march
    float sceneIntersectionDistance = ((sceneWorldPos - rayOrigin) / rayDirection).x; // distance to the intersection point of ray with scene depth

    // bigger ray marching steps before we encounter smoke voxels
    while (voxelValue == 0 && traveledDistance < MAX_DISTANCE)
    {
        traveledDistance = traveledDistance + stepSize; // larger step size to cover more ground
        currentPosition = rayOrigin + traveledDistance * rayDirection;
        voxelValue = getVoxelValue(currentPosition);
    }

    // encountered smoke, return value
    if (voxelValue > 0)
    {
        encountered = 1;
        _SmokeMaskTex[id.xy] = 1;
        return;
    }
   
}


[numthreads(8,8,8)]
void CS_NoiseGenerate (uint3 id : SV_DispatchThreadID)
{
    
}


